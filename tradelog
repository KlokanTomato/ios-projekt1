#!/bin/bash

export POSIXLY_CORRECT=yes
export LC_NUMERIC=en_US.UTF-8

print_help()
{
    echo "**Tradelog**"
    echo ""
    echo "Usage:"
    echo "  tradelog [-h|--help] [FILTER] [COMMAND] [LOG [LOG2 [...]]"
    echo ""
    echo "Commands: (one per run)"
    echo "  list-tick"
    echo "          summary of the all tickers occured in the logs"
    echo "  profit"
    echo "          printage of the total income form the closed positions"
    echo "  pos"
    echo "          prints values of the currently held positions in descending order"
    echo "  last-price"
    echo "          prints the last known price for each ticker"
    echo "  hist-ord"
    echo "          print the histogram of count of the all transactions for each of the tickers"
    echo "          standard output is one # per transaction, can be modified using -w"
    echo "  graph-pos"
    echo "          print the graph of values of the held positions for each held ticker"
    echo "          standard output is 1000 USD per symbol, can be modified by using -w"
    echo "          # === gain, ! === loss"
    echo ""
    echo "Filters: (combination of)"
    echo "  -a DATETIME"
    echo "          after: prints only the records after the date given in DATETIME,"
    echo "          records of the DATETIME are not considered"
    echo "          the format of the DATETIME is: YYYY-MM-DD HH:MM:SS"
    echo "  -b DATETIME"
    echo "          before: prints only the records before the date given in DATETIME,"
    echo "          records of the DATETIME are not considered"
    echo "          the format of the DATETIME is: YYYY-MM-DD HH:MM:SS"
    echo "  -t TICKER"
    echo "          only the records of the given TICKER are considered"
    echo "          if more occurences of the -t filter are found, tradelog"
    echo "          will display all records of given tickers"
    echo "  -w WIDTH"
    echo "          sets the count for the most symbols on one row"
    echo "          multiple occurences of -w are considered as a mistake"
    echo "Unlisted:"
    echo "  -h | --help:"
    echo "          Prints help for the usage of the script"
    echo ""

    return 0
}

list_tick_fc()
{
    awk -F";" '{if ( a[$2] != "" ) {a[$2] = $2}} END {for (i in a) {printf("%s\n", i)}}'
}

profit_fc()
{
    awk -F";" '{if ($3 == "sell") {profit += $4 * $6} else if ($3 == "buy") {profit -= $4 * $6}} END {printf("%.2f\n",profit)}'
}

pos_fc()
{
    awk -F";" '{last_price[$2]=$4; if ($3 == "buy") {count[$2]+=$6} else if ($3 == "sell") {count[$2]-=$6}}
    END {for (key in count) {if (count[key] != "0") {value[key]=last_price[key] * count[key]}}
    for (key2 in value) {value[key2] = sprintf("%.2f",value[key2]); if (maxLength < length(value[key2])) {maxLength = length(value[key2])}}
    for (key3 in value) {printf("%-10s: %*s\n", key3, maxLength, value[key3])}}'
}

last_price_fc()
{
    awk -F";" '{last_price[$2] = sprintf("%.2f", $4); if (length(last_price[$2]) > maxlength) {maxlength=length(last_price[$2])}}
    END {for (key in last_price) {printf("%-10s: %*s\n", key, maxlength, last_price[key])}}'
}

graph_pos_fc() #with optional parameter WIDTH
{
    awk -F";" -v WIDTH=$1 'function abs(v) {return v < 0 ? -v : v}
    {last_price[$2]=$4; if ($3 == "buy") {count[$2]+=$6} else if ($3 == "sell") {count[$2]-=$6}}
    END {for (key in count) {if (count[key] != "0") {value[key]=last_price[key] * count[key]}}
    for (key2 in value) {if (abs(value[key2]) > maxAbs) {maxAbs=abs(value[key2])}} 
    if (WIDTH == "") {oneStep = 1000} else {oneStep = maxAbs / WIDTH};
    for (key3 in value) {if (value[key3] < 0) {symbol = "!"} else {symbol = "#"}
    repete = abs(value[key3]) / oneStep; sub(/\..*/, "", repete);
    printf("%-10s: ", key3); for (i=0; i != repete ;i++) {printf("%s",symbol)} printf("\n")}}'
}

hist_ord_fc() #with optional parameter WIDTH
{
    if [ "$1" = "" ]; then
        awk -F";" '{histo[$2] = histo[$2] "#"}
        END {for (key in histo) {printf("%-10s: %s\n", key, histo[key])}}'
    else
        awk -F";" -v width=$1 '{histo[$2]++;} 
        END {for (key in histo) {if (histo[key] > max) {max = histo[key]}}
        oneSymbol = max / width;
        for (key2 in histo) {count = histo[key2]/oneSymbol; sub(/\..*/, "", count);
        printf("%-10s: ", key2); for (i=0; i != count; i++) {printf("#")} printf("\n")}}'
    fi
}

TICKERS=";"  #means, that every ticker should be processed
COMMAND=""
ATIME="0000-00-00 00:00:00"
BTIME="9999-99-99 99:99:99"
WIDTH=""
LOGS=""

if [ $# -eq 0 ]; then
    awk '{print $0}'
    exit 0
fi

for (( a=1; a <= $#; a++ ))
do
    eval b=\${$a}
    case $b in
        list-tick|profit|pos|last-price|hist-ord|graph-pos)
            if [ "$COMMAND" != "" ]
            then
                echo "$b: Multiple commands are not supported during one run of the script"
                exit 1
            else
                COMMAND=$b
            fi
            ;;
        -a)
            if [ "$ATIME" != "0000-00-00 00:00:00" ]
            then
                echo "-a DATEIME: -a can be called only once per run"
                exit 1
            else
                (( a++ ))
                eval ATIME=\${$a}
                if [[ !($ATIME =~ [0-9]{4}-[0-9]{2}-[0-9]{2}\ [0-9]{2}:[0-9]{2}:[0-9]{2}) ]]; then
                    echo "-a DATETIME: Invalid date format, use a format of YYYY-MM-DD HH:MM:SS"
                    exit 1
                fi
            fi
            ;;
        -b)
            if [ "$BTIME" != "9999-99-99 99:99:99" ]
            then
                echo "-b DATETIME: -b can be called only once per run"
                exit 1
            else
                (( a++ ))
                eval BTIME=\${$a}
                if [[ !($BTIME =~ [0-9]{4}-[0-9]{2}-[0-9]{2}\ [0-9]{2}:[0-9]{2}:[0-9]{2}) ]]; then
                    echo "-b DATETIME: Invalid date format, use a format of YYYY-MM-DD HH:MM:SS"
                    exit 1
                fi
            fi
            ;;
        -t)
            (( a++ ))
            eval TICKERS="\$TICKERS\${$a}\;"
            ;;
        -w)
            if [ "$WIDTH" != "" ]; then
                echo "-w WIDTH: -w can't be called more than once"
                exit 1
            fi
            (( a++ ))
            eval WIDTH=\${$a}
            if [[ !($WIDTH =~ ^[0-9]+$) ]]; then
                echo "-w WIDTH: argument must be unsigned whole number"
                exit 1
            fi
            ;;
        -h|--help)
            print_help
            exit 0
            ;;
        
        *.log)  
            LOGS="$LOGS$b"
            if [ $a -ne $# ]; then
                LOGS="$LOGS "
            fi
            ;;

        *.gz)
            GZIP="$GZIP$b"
            if [ $a -ne $# ]; then
                GZIP="$GZIP "
            fi
            ;;
        *)
            echo "$b: Unknown structure"
            exit 1
    esac                  
done

if [[ $GZIP == "" ]] && [[ $LOGS != "" ]]; then
    READ_INPUT="cat $LOGS | sort"
elif [[ $GZIP != "" ]] && [[ $LOGS == "" ]]; then
    READ_INPUT="gzip -d -c $GZIP | cat - | sort"
elif [[ $GZIP != "" ]] && [[ $LOGS != "" ]]; then
    READ_INPUT="gzip -d -c $GZIP | cat $LOGS - | sort"
else
    READ_INPUT="cat - | sort"
fi


#-a filter
AFILTER="awk -F\";\" -v timeA=\"$ATIME\" 'timeA < \$1 {print \$0}'"
#-b filter
BFILTER="awk -F\";\" -v timeB=\"$BTIME\" 'timeB > \$1 {print \$0}'"

TFILTER="awk -F\";\" -v TICKERS=\"$TICKERS\" '{\
    var = sprintf(\";%s;\", \$2);
    if (TICKERS == \";\") {
        print \$0}
    else if (TICKERS ~ var){
        print \$0}}'"

case $COMMAND in
    list-tick)
        eval $READ_INPUT | eval $AFILTER | eval $BFILTER | eval $TFILTER | list_tick_fc | sort
        ;;
    profit)
        eval $READ_INPUT | eval $AFILTER | eval $BFILTER | eval $TFILTER | profit_fc
        ;;
    pos)
        eval $READ_INPUT | eval $AFILTER | eval $BFILTER | eval $TFILTER | pos_fc | sort -nr -t ':' -k2
        ;;
    last-price)
        eval $READ_INPUT | eval $AFILTER | eval $BFILTER | eval $TFILTER | last_price_fc | sort
        ;;
    hist-ord)
        eval $READ_INPUT | eval $AFILTER | eval $BFILTER | eval $TFILTER | hist_ord_fc "$WIDTH" | sort
        ;;
    graph-pos)
        eval $READ_INPUT | eval $AFILTER | eval $BFILTER | eval $TFILTER | graph_pos_fc "$WIDTH" | sort
        ;;

    "")
        eval $READ_INPUT | eval $AFILTER | eval $BFILTER | eval $TFILTER
        ;;
    *)
        echo "An unexpected error occured during a chosing of a process"
        exit 1
        ;;
esac

exit 0